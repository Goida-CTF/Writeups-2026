# обычный чел | rev

## Обзор

Крекмишка на расте с использованием проклятых регулярок для проверки.

## Общая структура

В начале мейн флаг парсится clap (эту часть пропускаем). Затем проверяется его длина (42), он паддится до кратного четырем значению длины. После инициализируется 2 регекса (о них позже). Адская развернутая структура итератов по сути сводится к тому, что в цикле к каждым 4 элементам применяются некие коэффициенты и проверяется регулярка. Если все регулярки проходят то флаг подходит.

## Регулярки

Ключевая особенность таска — использование регулярных выражений для проверки арифметических операций в унарной системе счисления.

### Проверка простых чисел

Первая регулярка это знаменитая регулярка для проверки, что число не является простым:

```regex
^.?$|^(..+?)\1+$
```

Это работает так:
- `^.?$` — ловит 0 и 1 (не простые)
- `^(..+?)\1+$` — ловит составные числа: если строку можно представить как повторение меньшей строки, то это составное число

### Скалярное произведение

Вторая регулярка проверяет на верность скалярное произведение в унарной записи.

Формат проверки: `[a1,a2,a3,a4]@[b1,b2,b3,b4]=result`. Получить запись можно, посмотрев на то что проверяется в дебаггере.

Регекс использует:
- Именованные группы захвата для `a_i`
- Обратные ссылки для повторения `(?P=a1){k}` — повторить группу `a1` ровно `k` раз
- Альтернации для перебора всех возможных длин `b_i`

## Складываем 2 кусочка пазла

Каждый чанк из 4 символов флага приводится к форме `[f1,f2,f3,f4]` в унарной записи.

```
unsigned __int64 *__fastcall <alloc::vec::Vec<alloc::string::String> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<alloc::string::String, core::iter::adapters::map::Map<core::slice::iter::Iter<u8>, obichniy_chel::main::{closure#0}::{closure#0}>>>::from_iter(
        unsigned __int64 *a1,
        __int64 *a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  unsigned __int64 v4; // r13
  __int64 v5; // r12
  __int64 v6; // rax
  __int64 v7; // r14
  __int64 v8; // rbx
  unsigned __int64 v10; // [rsp+0h] [rbp-68h]
  __int64 v11; // [rsp+8h] [rbp-60h]
  __int128 v12; // [rsp+20h] [rbp-48h] BYREF
  __int64 v13; // [rsp+30h] [rbp-38h]

  v2 = *a2;
  v3 = a2[1];
  v4 = v3 - *a2;
  if ( v4 > 0x555555555555555LL )
  {
    v5 = 0;
    goto LABEL_3;
  }
  if ( !(24 * v4) )
  {
    v7 = 8;
    v10 = 0;
    v11 = 8;
    if ( v2 == v3 )
      goto LABEL_11;
    goto LABEL_9;
  }
  RNvCs7t1JAls2wor_7___rustc35___rust_no_alloc_shim_is_unstable_v2(a1);
  v5 = 8;
  v6 = __rustc::__rust_alloc(24 * v4, 8);
  if ( !v6 )
LABEL_3:
    alloc::raw_vec::handle_error(v5, 24 * v4);
  v7 = v6;
  v10 = v4;
  v11 = v6;
  if ( v2 != v3 )
  {
LABEL_9:
    v8 = 0;
    do
    {
      <[u8]>::repeat(
        &v12,
        anon_fb82b3b00dab93905fdd8d820dc3f426_48_llvm_9395937776163797565,
        1,
        *(unsigned __int8 *)(v2 + v8));
      *(_QWORD *)(v7 + 16) = v13;
      *(_OWORD *)v7 = v12;
      ++v8;
      v7 += 24;
    }
    while ( v4 != v8 );
  }
LABEL_11:
  a1[2] = v4;
  *a1 = v10;
  a1[1] = v11;
  return a1;
}
```

Затем аналогично приводится к такому же виду второй вектор, за ислючением того, что на числах в унарной форме вызывается `compute::np`. Как не трудно догадатся это функция находит следующее простое число с помощью вышеописанное регулярки.

## Решение

Парсим коэффициенты и целевые значения с помощью grep/vim магии и [скрипт](ida_script.py). Решаем матричные уравнения для всех чанков, обрезаем до 42 символов и сдаем.

[solve](solve.sage)

## Флаг

```
goidactf{b4efd05cdc57cd5656192303b555b193}
```