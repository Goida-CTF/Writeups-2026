# Знание Древних - Writeup

## TL;DR
Требовалось писать и сдавать код на языке `В††`, прорешать так все 25 итераций заданий и получить за это флаг.

Репозиторий языка находится здесь: https://github.com/KanatnikovMax/znanie-drevnix

## Writeup

Для начала требовалось понять в чем рофл таска, и что же ожидается в первом задании, ведь стандартный "Hello, World!" на разных языках не проходит. Понять, что требовалось писать какой-то код можно было по тому, что внизу страницы под хедером "Береста" было написано, что ожидается код.

Если загуглить "Знание Древних github", можно найти репозиторий https://github.com/KanatnikovMax/znanie-drevnix - посвященный языку программирования `В††` (который на самом деле является просто редефайнами ключевых слов из C++). На данном языке и требовалось писать код в зависимости от **задания итерации** (я дальше буду именно так называть ТЗ, которое каждый раз дает Древний Рус), сделать нужно было так все 25 подряд правильно, после чего в конце получался флаг. Сам же код исполнялся в сендбоксе с автопроверкой по тест кейсам, вывод сверялся регистронезависимо и в некоторых итерациях у заданий было несколько возможных ответов. Из интересного также является то, что для решения некоторых заданий итераций специально требовались знания лора данного языка. Сложностью также являлось то, что после решения первого задания итерации, на каждое следующее решение давалось лишь 30 секунд, что потребовало для эффективности решения в начале достать все условия итераций, а потом уже либо автоматизировать саму посылку ответов по веб-сокету, либо начать итеративно закидывать код на фронтенд (последний способ самый трушный, и да, некоторые решили потом так в конце сделать, чтобы увидеть флаг, но об этом чуть позже).

Лор по языку `В††` можно было найти на канале автора: https://www.youtube.com/@VatagaRUS, это можно было найти в README репозитория.

Также хочется отметить, что со временем я подправил формулировки внутри заданий итераций, чтобы формат ожидаемого ввода и вывода был чуть очевидней, а также добавил подсказки для решений некоторых итераций: эти подсказки по тексту должны были понимать люди, но тем временем GPT должен был не понимать (в каком-то плане у меня это получилось).

Все тесткейсы для заданий итераций находятся в файле [`../znaniye_deploy/data/tasks.yaml`](../znaniye_deploy/data/tasks.yaml), поэтому здесь я буду называть задания итераций по их ID в этом файле, из интересных хочется отметить следующие:
- `id: 0`: требовалось написать в консоль "`Славься Русь!`", что является классическим приветствием для языка `В††`, как видно из видео на канале автора, а также это можно было найти в папке `examples` репозитория с подписью "пишем первую программу на В††":
  - https://youtu.be/KffVhdWAgXc
  - https://github.com/KanatnikovMax/znanie-drevnix/blob/main/examples/Слава_Руси.cpp
- `id: 1`: изначально здесь предполагалось, что либо сразу все вспомнят "Выпил воды Байкальской, и погнал!", и в ответе будет "И погнал!" (с восклицательным знаком, как требует задание итерации), однако позже выяснилось (это еще когда у этого задания немного другой текст был), что могли также подумать на фразу из видео автора, где говорится "Русы, пейте воду из Байкала, пишите код на В крест крест" - поэтому под этот ответ также были добавлены варианты.
- `id: 2`: в качестве создателя языка по лору упоминается Белогор Страуструп, что и ожидалось в качестве ответа в этой итерации. Узнать это можно было из видео автора: https://youtu.be/gwaXYbcZQIs?t=27.
- Больше итераций, завязанных на знании лора не было, и остальные подразумевали собой решения каких либо задач на программирование. Важной задуманной уловкой, на которой многие попались - везде специально указывается, что язык используется славянский, и входные данные писали не ящеры, а Древние Русы. Это являлось прямой подсказкой на то, что входные данные представляют собой кириллицу из UTF-8, в то время как GPT всем писал код, заточенный под обычный ASCII - из-за чего код не проходил тесты (ведь кириллица в UTF-8 занимает 2 байта). Поэтому такие подсказки по задумке изначально мог понять только человек, а GPT бы не понимал прикола.

### Предполагаемое решение

Решение с самого начала предполагается через автоматизацию отправки кода. Это можно было понять по тому как после первой (нулевой) успешной итерации вдруг на последующие задания прилетает таймаут из-за малого количества времени в 30 секунд. Решающие через фронтенд без автоматизации должны были довольно быстро отваливаться, при учете того, что при нахождении нового условия и закидывания его в GPT, последний не должен был успевать сгенерировать нормального решения под задание итерации. А также сами условия построены на то, что GPT не решит их с первого раза (по крайней мере все сразу), что вынуждало писать автоматизацию под более удобное и менее болезненное решение.

Для начала требовалось понять протокол веб-сокета, сам протокол описан в пакете внутри [`../znaniye_deploy/internal/ws/`](../znaniye_deploy/internal/ws/), в кратце: структуру клиентских и серверных JSON-сообщений можно было понять через анализ фронтэнда, либо нажать F12 и смотреть как там шлётся трафик.

После этого требовалось достать 24 итерации заданий (в сумме итераций 25, но первая итерация всегда имеет одно и то же задание). Дальше можно было либо сразу долбить бэкенд попытками решений, либо же чуть задуматься, самому поанализировать код и попытаться поподгонять под задания итераций, а потом уже долбить. В любом случае рано или поздно всё скорее всего придёт к тому, что большинство итераций смогут решаться, но останется 2-3 последние, где придётся помучаться и побольше подумать (опять же на лоровых заданиях и заданиях, связанными с UTF-8).

После решения всех 25 итераций подряд, флаг можно было найти внутри сервер-мессаджа с типом `win` - флаг находился внутри поля "`flag`".

Внутри директории [`./code/`](./code/) можно найти решения для каждого из заданий итераций, весь код написан полностью на `В††`. Можно сопоставить поле `id` из файла заданий итераций [`../znaniye_deploy/data/tasks.yaml`](../znaniye_deploy/data/tasks.yaml) и найти соответствующий каждому ID код в файле `task{id}.cpp`.

Также можно достаточно легко запустить сервис для самостоятельного перерешивания, внутри файла [`../znaniye_deploy/docker-compose.yml`](../znaniye_deploy/docker-compose.yml) потребуется раскомментировать поле `ports` у сервиса `nginx`, а также для сети `exported` закомментировать поле `external`, раскомментировав `driver`. Ну и переменную окружения `FLAG` проставить нужно не забыть.

#### Анинтендед облегчение таска
> Которое никто не заметил (надеюсь)

Дело в том, что таск в итоге имел анинтендед облегчение, которое я заметил лишь на втором солве. Я решил это облегчение не исправлять, потому что решил, что тогда это могло дать преимущество первым двум солвнувшим командам, а также потому что никто это облегчение не заметил (по крайней мере как я понял).

Суть заключается в том, что изначально задумывалось, что при написании кода будет запрещено применение любых английских символов (`\[a-zA-Z]\`), за исключением `#include` и строки внутри (для подключения хедер-файла языка `В††`, ибо такова условность "кастомных" языков поверх C++). Это должно было быть обусловлено тем, что канонично весь код на языке `В††` всегда и везде пишется без применения английских символов. Это также обуславливало бы зачем в принципе решение должно было писаться на `В††`. На данную фичу должно было отсылать поле "`containsNonRuChars`" из сервер-мессаджа с результатом выполнения кода в сендбоксе. О существовании этого ограничения по задумке можно было только при инспектировании протокола веб-сокета, ибо на фронтенд бы просто отправлялось, что код был неверен, а почему конкретно, когда вроде бы сам код рабочий - нужно было догадаться.

При тестировании я как-то удалил один важный `if` в файле [../znaniye_deploy/internal/usecases/task_runner.go](../znaniye_deploy/internal/usecases/task_runner.go), что и привело к облегчению таска (я там добавил комментарий, чтобы можно было по желанию себе локальную версию пофиксить).

Поэтому на самом деле код можно было писать на обычном C++, без какого либо использования дефайнов ключевых слов из `В††` :D

Вот такой код пройдёт первую (нулевую) итерацию:
```cpp
#include <iostream>

int main() {
  std::cout << "Славься Русь!\n";
  return 0;
}
```

Однако, как вы уже могли догадаться (если вы решали таск), этого никто не заметил по той причине, что как только все откапывали `В††`, а конкретно код первой программы всех добрых молодцев и красно девиц, то сразу же начинали писать только на нём. А кто-то мог и не заметить, из-за чего как я видел могли применять всякие инклуды наподобие `<vector>` и т.д., но дефайны ключевых слов из `В††` всё равно применяли. Вот такой вот получился интересный эксперимент.

P.S.: интересное замечание, `В††` пишется через русскую букву В, а не английскую B (Би) - благодаря этому код первой программы на `В††` не содержит английских символов (`#include` и строка - исключение), а значит код должен был проходить всегда, что могло вызвать удивление от вот этого условия, которое по итогу оказалось выключено. Так что таким образом изначально было задумано возможно кого-то запутать :)
