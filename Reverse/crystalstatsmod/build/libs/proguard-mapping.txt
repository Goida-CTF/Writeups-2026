ru.goida.crystalstatsmod.CrystalStatsMod -> ru.goida.crystalstatsmod.CrystalStatsMod:
    java.lang.String MOD_ID -> MOD_ID
    org.slf4j.Logger LOGGER -> LOGGER
    ru.goida.crystalstatsmod.CrystalStatsMod instance -> a
    ru.goida.internal.core.DiagnosticsCore diagnosticsCore -> b
    void <init>() -> <init>
    void onInitialize() -> onInitialize
    ru.goida.crystalstatsmod.CrystalStatsMod getInstance() -> getInstance
    ru.goida.internal.core.DiagnosticsCore getDiagnosticsCore() -> getDiagnosticsCore
    java.lang.String getSecurityTokenDisplay() -> getSecurityTokenDisplay
    void <clinit>() -> <clinit>
ru.goida.crystalstatsmod.client.CrystalStatsHud -> ru.goida.crystalstatsmod.client.CrystalStatsHud:
    boolean visible -> a
    long lastUpdateTime -> b
    java.lang.String cachedToken -> c
    void <init>() -> <init>
    void render(net.minecraft.class_332,net.minecraft.class_9779) -> render
    void updateToken() -> a
    void toggleVisibility() -> toggleVisibility
    boolean isVisible() -> isVisible
    void setVisible(boolean) -> setVisible
ru.goida.crystalstatsmod.client.CrystalStatsModClient -> ru.goida.crystalstatsmod.client.CrystalStatsModClient:
    ru.goida.crystalstatsmod.client.CrystalStatsHud hudRenderer -> a
    void <init>() -> <init>
    void onInitializeClient() -> onInitializeClient
    void registerCommands() -> a
    void lambda$registerCommands$2(com.mojang.brigadier.CommandDispatcher,net.minecraft.class_7157) -> a
    int lambda$registerCommands$1(com.mojang.brigadier.context.CommandContext) -> a
    int lambda$registerCommands$0(com.mojang.brigadier.context.CommandContext) -> b
ru.goida.internal.core.DiagnosticsCore -> ru.goida.o.a:
    java.util.concurrent.atomic.AtomicBoolean initialized -> a
    java.util.concurrent.atomic.AtomicBoolean ready -> b
    java.util.concurrent.atomic.AtomicReference tokenDisplay -> c
    java.lang.Thread initThread -> d
    long systemSeed -> e
    int integrityHash -> f
    void <init>() -> <init>
    void initialize() -> a
    void performInitialization() -> d
    long generateSystemSeed() -> e
    int calculateIntegrityHash() -> f
    java.lang.String generateDisplayToken() -> g
    boolean isReady() -> b
    java.lang.String getTokenDisplay() -> c
ru.goida.internal.reflect.FlagAssembler -> ru.goida.o.b:
    byte[] ENCRYPTED_FINAL_FRAGMENT -> a
    int ASSEMBLY_MAGIC -> b
    byte FINAL_XOR_KEY -> c
    java.lang.String FLAG_PREFIX -> d
    java.lang.String FLAG_SUFFIX -> e
    void <init>() -> <init>
    java.lang.String assembleFlag(byte[],byte[]) -> a
    byte[] decryptFinalFragment() -> a
    byte[] combineAllFragments(byte[],byte[]) -> b
    boolean validateFlagFormat(java.lang.String) -> a
    java.lang.String reconstructFlag(byte[],byte[]) -> c
    void <clinit>() -> <clinit>
ru.goida.internal.reflect.HiddenPayloadA -> ru.goida.o.c:
    byte[] ENCRYPTED_FRAGMENT -> a
    byte XOR_KEY -> b
    int PAYLOAD_MAGIC -> c
    int CHAIN_POSITION -> d
    java.lang.String NEXT_STAGE -> e
    void <init>() -> <init>
    java.lang.String processPayload(byte[],int) -> a
    byte[] decryptFragment(byte) -> a
    byte[] createAugmentedKey(byte[],byte[]) -> a
    java.lang.String invokeNextStage(byte[],byte[]) -> b
    void <clinit>() -> <clinit>
ru.goida.internal.reflect.HiddenPayloadB -> ru.goida.o.d:
    byte[] ENCRYPTED_FRAGMENT -> a
    int PAYLOAD_MAGIC -> b
    int CHAIN_POSITION -> c
    java.lang.String NEXT_STAGE -> d
    byte BASE_KEY -> e
    void <init>() -> <init>
    java.lang.String processPayload(byte[],byte[]) -> a
    byte deriveXorKey(byte[],byte[]) -> b
    byte[] decryptFragment(byte) -> a
    byte[] combineFragments(byte[],byte[]) -> c
    byte[] createFinalKey(byte[],byte[]) -> d
    java.lang.String invokeFlagAssembler(byte[],byte[]) -> e
    void <clinit>() -> <clinit>
ru.goida.internal.reflect.ReflectorChainStart -> ru.goida.o.e:
    int CHAIN_MAGIC -> a
    java.lang.String NEXT_STAGE -> b
    boolean chainInitialized -> c
    long chainTimestamp -> d
    void <init>() -> <init>
    java.lang.String initiateChain() -> a
    boolean performPreflightChecks() -> b
    byte[] generateInitialKey() -> c
    java.lang.String invokeNextStage(byte[]) -> a
    int calculatePositionMarker() -> d
    java.lang.String postProcessResult(java.lang.String) -> a
    void <clinit>() -> <clinit>
ru.goida.internal.security.DebuggerDetector -> ru.goida.o.f:
    java.lang.String[] DEBUG_INDICATORS -> a
    java.lang.String[] DEBUGGER_THREADS -> b
    java.lang.Boolean cachedResult -> c
    long lastCheckTime -> d
    void <init>() -> <init>
    boolean isDebuggerPresent() -> a
    boolean checkJvmArguments() -> c
    boolean checkDebuggerThreads() -> d
    boolean checkSystemProperties() -> e
    boolean checkTimingAnomaly() -> f
    int getSecurityStateHash() -> b
    void <clinit>() -> <clinit>
ru.goida.internal.security.IntegrityVerifier -> ru.goida.o.g:
    boolean verificationComplete -> a
    boolean verificationResult -> b
    void <init>() -> <init>
    boolean verifyIntegrity() -> a
    boolean verifyClassStructure() -> c
    boolean verifyMethodSignatures() -> d
    boolean verifyFieldLayout() -> e
    boolean verifyCrossReferences() -> f
    int computeClassHash(java.lang.Class) -> a
    int getExpectedCoreSignature() -> b
    void <clinit>() -> <clinit>
